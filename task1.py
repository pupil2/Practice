def cesar(textp, key, alf):
    """функция расшифровки шифра Цезаря"""
    dectext="" #здесь будет расшифрованное сообщение
    for symbol in textp: #перебираем символы
        f=0 
        if symbol==symbol.title(): # если символ-заглавный
            f=1 # то флаг равен 1
        symbol=symbol.lower() # приводим символ к строчному виду
        index=alf.find(symbol) # находим индекс символа в алфавите
        if index==-1: # Если символа нет в алфавите,
            dectext+=symbol # то символ расшифровывать не нужно
        else:
            symbol=alf[(index-key)%len(alf)] #расшифровываем символ
            if f: # если символ был заглавным,
                symbol=symbol.title() #преобразуем его 
            dectext+=symbol
    return dectext
with open("enctext.txt") as f:
    texts=f.read() #читаем зашифрованный текст из файла
 
texts_list=[] #нужно текст разбить на части(см. условие), хранящиеся в данном списке
i,j=0,0 #i-индекст начала каждой новой части, j-индекс последней точки для текущей позиции
for index,symbol in enumerate(texts,0): # проходим по всем символам и их индексам в тексте
    if symbol==".": #если символ-точка,
        j=index+1 # обновляем j
    elif symbol=="?": #если символ-знак вопроса,
        texts_list.append(texts[i:j]) #добавляем в список данную часть
        i=j #обновляем значения i и j
        j=index+1
texts_list.append(texts[i:j]) #Добавляем в список последнюю часть(не рассмотренную в цикле)
#Один из возможных выриантов решения-перебор всевозможных расшифровок и поиск в них настоящих английских слов
with open("popwords.txt") as f:
    pwords=f.read().split() # Был сформирован список самых часто употребляемых слов английского языка
alf="".join([chr(i) for i in range(ord("a"),ord("z")+1)]) # формируем алфавит
keys=[] #список, в котором будут храниться ключи для каждой части
dectext="" # здесь будет записан расшифрованный текст
for text in texts_list: #перебор раннее сформированных частей
    if text=="": #если часть пустая, то переходим к следующей
        continue
    #Во время перебора будем хранить значения ключа, при котором в расшифровке встречается больше всего реальных слов
    max=[0,0,0] # [counter,key,text]
    for key in range(27): #перебираем ключи
        text1=cesar(text, key,alf) # расшифровка
        text2="".join([symbol.lower() for symbol in text1]) # преобразуем расшифровку к строчным символам
        count=0 #счетчик реальных слов в тексте
        for word in pwords: # перебираем слова и находим их число в расшифровке
            count+=text2.count(word)
        if count>max[0]: # если реальных слов в данном тексте больше максимума, значит, мы нашли более вероятную расшифровку
            max=[count,key,text1]
    keys.append(max[1]) # Добавляем ключ для самой вероятной расшифровки,
    dectext+=max[2] # а ее саму добавляем в текст
        
print("keys{"+f"{str(keys)[1:-1]}"+"}") # печатаем ключ
with open("dectext.txt","w") as f:
    f.write(dectext) #сохраняем в файл расшифрованный текст
